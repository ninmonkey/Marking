<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<Events><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event><Event xmlns='http://schemas.microsoft.com/win/2004/08/events/event'><System><Provider Name='PowerShellCore' Guid='{f90714a8-5509-434a-bf6d-b1624c8a19a2}'/><EventID>4104</EventID><Version>1</Version><Level>3</Level><Task>2</Task><Opcode>15</Opcode><Keywords>0x0</Keywords><TimeCreated SystemTime='2022-03-22T19:19:22.7962929Z'/><EventRecordID>2042411</EventRecordID><Correlation ActivityID='{4fc99355-3c93-000b-e327-0450933cd801}'/><Execution ProcessID='51104' ThreadID='51152'/><Channel>PowerShellCore/Operational</Channel><Computer>nin8</Computer><Security UserID='S-1-5-21-572729905-3085656190-587020618-1001'/></System><EventData><Data Name='MessageNumber'>1</Data><Data Name='MessageTotal'>1</Data><Data Name='ScriptBlockText'>#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}
</Data><Data Name='ScriptBlockId'>de5a51fb-6331-4a19-872c-df0aa2e142fe</Data><Data Name='Path'>C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Data></EventData><RenderingInfo Culture='en-US'><Message>Creating Scriptblock text (1 of 1):
#Requires -Version 7

if ( $experimentToExport ) {
    $experimentToExport.function += @(
        'Resolve-TypeName'
    )
    $experimentToExport.alias += @(
        'FullName'      # 'Resolve-TypeName'
        'To-&gt;TypeName'  # 'Resolve-TypeName'
    )
}


function Resolve-TypeName {
    &lt;#
    .SYNOPSIS
        Resolve a type's FullName from an instance, a 'type', typename as a string, or using wildcards.
    .description
        If type isn't found, it will use a wildcard search using 'ClassExplorer\Find-Type'
    .notes
        future:
            - [ ] optionally run output through [Format-TypeName] to strip extra 'AssemblyQualifiedName' info

        related:
            [AppDomain]::CurrentDomain.GetAssemblies()
            [System.Management.Automation.PSTypeName]

            /EditorServicesCommandSuite/Reflection/MemberUtil.cs | ResolveTypes
            https://github.com/SeeminglyScience/EditorServicesCommandSuite/blob/52d079f6de0c00eb66034acd940fa3abf520d039/src/EditorServicesCommandSuite/Inference/InferenceExtensions.cs#L160

    .example
        PS&gt;  # partial finds

        $foo | FullName
        $foo.GetType() | FullName
        'Toast*' | FullName
        'ConsoleColor' | FullName
    #&gt;

    [CmdletBinding(  )]
    [Alias(
        'FullName',
        'To-&gt;TypeName'
    )]
    [OutputType([String])]

    Param (
        # you pass an object, name as text, a type instance, or even type name as a wildcard , name, string, instance
        # or even strings with wildcards
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [object]$InputObject

        # # Copy to clipboard
        # [alias('Clip')]
        # [Parameter()][switch]$SetClipboard

        # also check first element?
        # [Parameter()]
        # [switch]$IncludeChild


    )

    begin {
        # function _maybeExport {
        #     param()
        #     if ($SetClipboard) {
        #         $InputObject.GetType().Fullname | Set-Clipboard
        #     }
        # }
    }

    process {

        # original was stable
        if ($False) {
            #
            # function _resolveTypeInfo {
            #     # resolve as typeinfo
            #     param( $Type )
            #     $tinfo = if ($Type -is 'type') {
            #         $Type
            #     } else {
            #         ($Type)?.GetType() ?? "`u{2400}"
            #     }
            #     return $tinfo
            # }
        }

        # $target = (Get-Item . | ForEach-Object GetTYpe )
        try {
            # this implicityly catches strings, in all cases ?
            $target = $InputObject
            $isType = $target -as 'type' -is 'type'
            # wont this lose pstypenames, if added?
            #       $target -as 'type' -is 'type'

            $tinfo = $isType ? $target -as 'type' : $target.GetType()
        } catch {
            if ($_ -match 'unable to find type') {
                (Find-Type  ) | Assert-OneOrNone
            }

        }
        $tinfo
        hr
        return

        $isAType = $inputObject -as 'type' -is 'type'
        if (! $isAType ) {
            $tinfo = $InputObject.GetType()
        }
        $tinfo = $inputObject -as 'type'
        $tinfo = if ($InputObject -is 'type') {
            $Input
        }
        # if )


        Write-Warning 'jumping to old code'

        # type of type isn't useful here, so use typeinfo [RuntimeType] ?
        if ($InputObject -is 'type') {
            $InputObject.GetTypeInfo().Fullname
            return
        }
        # Assume strings are real types
        if ($InputObject -is 'string') {
            # if in the namespace
            $maybeTypeName = $InputObject -as 'type'
            if ($maybeTypeName) {
                $maybeTypeName.FullName
                return
            }
            $maybeTypeName = ClassExplorer\Find-Type -Name $InputObject
            if ($maybeTypeName.Count -eq 1) {
                $maybeTypeName.FullName
                return
            } elseif ( $maybeTypeName.Count -gt 1) {
                Write-Verbose "$($maybeTypeName.Count) matches found"
                $maybeTypeName.FullName
                return
            } else {
                ''.GetType().FullName
                return
            }
        }
        # it's a typeinfo, string, or string-wildcard
        $InputObject.GetType().Fullname
        return
    }

    end {
        # $Output | Sort-Object -Unique # did not work.
    }
}


if (! $experimentToExport) {
    # ...
}


ScriptBlock ID: de5a51fb-6331-4a19-872c-df0aa2e142fe
Path: C:\Users\cppmo_000\SkyDrive\Documents\2021\Powershell\My_Github\Dev.Nin\public_experiment\current\Resolve-TypeName.ps1</Message><Level>Warning</Level><Task>Execute a Remote Command</Task><Opcode>On create calls</Opcode><Channel>PowerShellCore/Operational</Channel><Provider></Provider><Keywords></Keywords></RenderingInfo></Event></Events>